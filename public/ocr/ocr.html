<html>

<head>
<style type="text/css">
video {
	display: none;
}
</style>
</head>

<body>
<div id="selector">
	<select id="device">
		<option value="0">Select the desired video device.</option>
	</select>
</div>

<video id="device_video" playsinline controls="false"></video>
<canvas id="capture"></canvas>
<br /><br />
<canvas id="processed"></canvas>
<br /><br />
<canvas id="score"></canvas>
<canvas id="score_scaled"></canvas>
<br /><br />
<canvas id="level"></canvas>
<canvas id="level_scaled"></canvas>
<br /><br />
<canvas id="lines"></canvas>
<canvas id="lines_scaled"></canvas>
<br /><br />
<canvas id="field"></canvas>
<canvas id="field_scaled"></canvas>
<br /><br />
<canvas id="preview"></canvas>
<canvas id="preview_scaled"></canvas>
<br /><br />
<canvas id="color1"></canvas>
<canvas id="color1_scaled"></canvas>
<br /><br />
<canvas id="color2"></canvas>
<canvas id="color2_scaled"></canvas>
<br /><br />
<!--canvas id="stats"></canvas>
<br /><br / -->
<div id="templates"></div>
<div id="frame_data"></div>
<div id="perf_data"></div>
<script src="../constants.js"></script>
<script src="./image_tools.js"></script>
<script>
	var exports = {};
</script>
<script src="./loader.js"></script>
<script src="./worker.js"></script>

<script>
// NTSC NES resolution: 256x224 -> 512x448

const SHOW_LOCAL = true;

const config = {
	deinterlace: true,
	tasks: {
		score:   { crop: [526, 62, 118, 7], pattern: "DDDDDD", red: false },
		level:   { crop: [566, 166, 38, 7], pattern: "TD", red: false },
		lines:   { crop: [426, 22, 57, 7], pattern: "TDD", red: false },
		field:   { crop: [284, 46, 201, 160], resize: [80, 160] },
		preview: { crop: [526, 118, 80, 15], resize: [31, 15] },
		// color1:  { crop: [80, 118, 8, 5], resize: [31, 15] },
		// color2:  { crop: [80, 200, 8, 5], resize: [31, 15] },
		// stats: { crop: [164, 93, 57, 105], red: true },
	}
};

let lowest_row;

function getLowestRow() {
	let lowest = -1;

	for (const { crop } of Object.values(config.tasks)) {
		const [x, y, w, h] = crop;
		const bottom = y + h;

		if (bottom > lowest) {
			lowest = bottom;
		}
	}

	lowest_row = lowest + 1; // + 1 for safety
}

getLowestRow();

// dom nodes
const
	device_selector = document.querySelector('#device'),
	video           = document.querySelector('#device_video'),
	capture         = document.querySelector('#capture'),
	capture_ctx     = capture.getContext('2d'),
	processed       = document.querySelector('#processed'),
	processed_ctx   = processed.getContext('2d'),
	frame_data      = document.querySelector('#frame_data'),
	perf_data       = document.querySelector('#perf_data'),

	dom = {
		score          : document.querySelector('#score'),
		score_scaled   : document.querySelector('#score_scaled'),
		lines          : document.querySelector('#lines'),
		lines_scaled   : document.querySelector('#lines_scaled'),
		level          : document.querySelector('#level'),
		level_scaled   : document.querySelector('#level_scaled'),
		field          : document.querySelector('#field'),
		field_scaled   : document.querySelector('#field_scaled'),
		preview        : document.querySelector('#preview'),
		preview_scaled : document.querySelector('#preview_scaled'),
		stats          : document.querySelector('#stats'),
	};

let entries;


device_selector.addEventListener('change', evt => {
	playVideoFromDevice(device_selector.value);
});

// Updates the select element with the provided set of cameras
function updateDeviceList(devices) {
    device_selector.innerHTML = '';

    const heading = [{
    	label: "Select your video device",
    	deviceId: "0"
    }];

    entries = heading.concat(devices);

    entries.forEach(camera => {
        const cameraOption = document.createElement('option');
        cameraOption.text = camera.label;
        cameraOption.value = camera.deviceId;

        device_selector.appendChild(cameraOption)
    });
}

async function getConnectedDevices(type) {
    return (await navigator.mediaDevices.enumerateDevices())
		.filter(device => device.kind === type && device.deviceId)
}

async function resetDevices() {
	const devicesList = await getConnectedDevices('videoinput');
	updateDeviceList(devicesList);
}

navigator.mediaDevices.addEventListener('devicechange', resetDevices);


let stream;

async function playVideoFromDevice(device_id) {
    try {
        const constraints = {
        	audio: false,
        	video: {
        		width: { ideal: 4096 },
        		height: { ideal: 2160 }
        	}
        };

        if (device_id) {
        	constraints.video.deviceId = { exact: device_id };
        }

        stream = await navigator.mediaDevices.getUserMedia(constraints);

        video.srcObject = stream;
        video.play();

        startCapture(stream);
    }
    catch(error) {
        console.error('Error opening video camera.', error);
        video.pause();
        capture_process = clearTimeout(capture_process); // window.cancelAnimationFrame(capture_process);
    }
}

let capture_process, blob;
let frame_count = 0;
let frame_ms = 1000/30;
let start_time_ms;

async function startCapture(stream) {
	const settings = stream.getVideoTracks()[0].getSettings();

	console.log(`Video settings: ${settings.width}x${settings.height}@${settings.frameRate.toFixed(1)}fps`);

	capture.width = settings.width;
	capture.height = settings.height;

	processed.width = settings.width;
	processed.height = settings.height / 2;

	config.width = settings.width;
	config.height = settings.height;

	setConfig();

	/*
	worker.postMessage({
		command: 'set_config',
		config
	});
	/**/

	const response = await fetch(`./full2.png`);
	blob = await response.blob();

	start_time_ms = Date.now();
	last_frame_time = start_time_ms;
	captureFrame();
}

async function captureFrame() {
	++frame_count;
	const now = Date.now();

	perf_data.textContent = now - last_frame_time;
	last_frame_time = now;

	try {
		// const bitmap = await createImageBitmap(blob);
		const bitmap = await createImageBitmap(video, 0, 0, video.videoWidth, video.videoHeight);

		if (SHOW_LOCAL) {
			capture_ctx.drawImage(bitmap, 0, 0, capture.width, capture.height);

			start = Date.now();

			const pixels = capture_ctx.getImageData(0, 0, capture.width, capture.height);

			processFrame(pixels);
		}

		processFrame2(bitmap);
		/*
		worker.postMessage(
			{
				command: 'frame',
				frame: bitmap
			},
			[
				bitmap
			]
		);
		/**/
	}
	catch(err) {
		console.error(err);
	}

	const next_frame_time = start_time_ms + frame_ms * frame_count;

	capture_process = setTimeout(captureFrame, Math.ceil(next_frame_time - Date.now()));
	// window.requestAnimationFrame(captureFrame);
}

function processFrame(pixels) {
	// de-interlace: top + drop

	const pixels_per_rows = pixels.width * 4;
	const max_rows = lowest_row; // pixels.height / 2;

	for (let row_idx = 1; row_idx < max_rows; row_idx++) {
		pixels.data.copyWithin(
			pixels_per_rows * row_idx,
			pixels_per_rows * row_idx * 2,
			pixels_per_rows * (row_idx * 2 + 1)
		);
	}

	processed_ctx.putImageData(pixels, 0, 0, 0, 0, pixels_per_rows, max_rows);

	processTasks(pixels);

	// console.log(Date.now() - start);
}

const x=0, y=0, w=100, h=7;

/*
console.log('loading worker');
const worker = new Worker('./worker.js');
worker.addEventListener('message', function(evt) {
	// we're receiving a frame, let's just
	frame_data.textContent = JSON.stringify(evt.data);
}, false);
/**/

function onMessage(data) {
	// make frame NESTrisOCR compatible
	data.score = `${data.score}`.padStart(6, '0');
	data.level = `${data.level}`.padStart(2, '0');
	data.lines = `${data.lines}`.padStart(3, '0');

	frame_data.textContent = JSON.stringify(data);

	if (producer_socket) {
		producer_socket.send(JSON.stringify(data));
	}
}


function processTasks(pixels) {
	for (const [name, task] of Object.entries(config.tasks)) {
		const canva = dom[name];
		const ctx = canva.getContext('2d');
		const [x, y, w, h] = task.crop;

		canva.width = w;
		canva.height = h;

		// ctx.putImageData(pixels, -x, -y, x, y, w, h);
		const cropped = new ImageData(w, h);

		crop(pixels, x, y, w, h, cropped);
		ctx.putImageData(cropped, 0, 0);

		const scaled = dom[`${name}_scaled`];

		if (task.pattern) {
			scaled.width = (8 * task.pattern.length - 1) * 2;
			scaled.height = h * 2;

			const scaled_img = new ImageData(scaled.width, scaled.height);

			bicubic(cropped, scaled_img);
			scaled.getContext('2d').putImageData(scaled_img, 0, 0);
		}
		else if (task.resize) {
			const scaled_img = new ImageData(scaled.width, scaled.height);

			scaled.width = task.resize[0];
			scaled.height = task.resize[1];

			bicubic(cropped, scaled_img);
			scaled.getContext('2d').putImageData(scaled_img, 0, 0);
		}
	}
}

/**/
playVideoFromDevice()
	.then(resetDevices);
/**/

/*
const fake_stream = {
	getVideoTracks() {
		return [{
			getSettings() {
				return {
					width: 720,
					height: 480,
					frameRate: 30.0
				}
			}
		}]
	}
};

startCapture(fake_stream);

function dummyInit() {
	const tpl = document.querySelector('#templates');

	for (let template of templates) {
		const canvas = document.createElement('canvas');
		canvas.width = 14;
		canvas.height = 14;
		const ctx = canvas.getContext('2d');
		const img = new ImageData(14, 14);
		for (let p_idx=template.length; p_idx--; ) {
			const luma = template[p_idx];
			const offset_idx = p_idx << 2;
			img.data[offset_idx] = luma;
			img.data[offset_idx + 1] = luma;
			img.data[offset_idx + 2] = luma;
			img.data[offset_idx + 3] = 255;
		}
		ctx.putImageData(img, 0, 0);
		tpl.appendChild(canvas);
	}
}

setTimeout(dummyInit, 500);
/**/

let producer_socket;

function handleWSError(err) {
	// ignore
}

function handleWSClose(evt) {
	// console.log('Socket close');
	clearSocket();
	setTimeout(connect, 25); // schedule reconnect
}

function clearSocket() {
	try {
		producer_socket.removeEventListener('error',  handleWSError);
		producer_socket.removeEventListener('close',  handleWSClose);
		producer_socket.close();
		producer_socket = null;
	}
	catch(e) {}
}

function connect() {
	if (producer_socket) {
		clearSocket();
	}

	producer_socket = new WebSocket('ws://127.0.0.1:3337');
	producer_socket.addEventListener('error',  handleWSError);
	producer_socket.addEventListener('close',  handleWSClose);
}

connect()


</script>
</body>
</html>