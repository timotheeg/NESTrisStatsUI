<html>

<head>
<style type="text/css">
video, #capture {
	display: none;
}
</style>
</head>

<body>
<div id="selector">
	<select id="device">
		<option value="0">Select the desired video device.</option>
	</select>
</div>

<video id="device_video" playsinline controls="false"></video>

<canvas id="capture"></canvas><br />
<canvas id="processed"></canvas>
<br /><br />
<canvas id="score"></canvas>
<br /><br />
<canvas id="level"></canvas>
<br /><br />
<canvas id="lines"></canvas>
<br /><br />
<canvas id="field"></canvas>
<br /><br />
<canvas id="stats"></canvas>
<br /><br />

<script>
// NTSC NES resolution: 256x224 -> 512x448

// OffscreenCanvas can be passed by reference

// dom nodes
const
	device_selector = document.querySelector('#device'),
	video           = document.querySelector('#device_video'),
	capture         = document.querySelector('#capture'),
	capture_ctx     = capture.getContext('2d'),
	processed       = document.querySelector('#processed'),
	processed_ctx   = processed.getContext('2d'),

	dom = {
		score          : document.querySelector('#score'),
		lines          : document.querySelector('#lines'),
		level          : document.querySelector('#level'),
		field          : document.querySelector('#field'),
		stats          : document.querySelector('#stats'),
	};

dom.score_ctx = dom.score.getContext('2d');
dom.lines_ctx = dom.lines.getContext('2d');
dom.level_ctx = dom.level.getContext('2d');
dom.field_ctx = dom.field.getContext('2d');
dom.stats_ctx = dom.stats.getContext('2d');

let entries;


device_selector.addEventListener('change', evt => {
	playVideoFromDevice(device_selector.value);
});

// Updates the select element with the provided set of cameras
function updateDeviceList(devices) {
    device_selector.innerHTML = '';

    const heading = [{
    	label: "Select your video device",
    	deviceId: "0"
    }];

    entries = heading.concat(devices);

    entries.forEach(camera => {
        const cameraOption = document.createElement('option');
        cameraOption.text = camera.label;
        cameraOption.value = camera.deviceId;

        device_selector.appendChild(cameraOption)
    });
}

async function getConnectedDevices(type) {
    return (await navigator.mediaDevices.enumerateDevices())
		.filter(device => device.kind === type && device.deviceId)
}

async function resetDevices() {
	const devicesList = await getConnectedDevices('videoinput');
	updateDeviceList(devicesList);
}

navigator.mediaDevices.addEventListener('devicechange', resetDevices);


let stream;

async function playVideoFromDevice(device_id) {
    try {
        const constraints = {
        	audio: false,
        	video: {
        		width: { ideal: 4096 },
        		height: { ideal: 2160 }
        	}
        };

        if (device_id) {
        	constraints.video.deviceId = { exact: device_id };
        }

        stream = await navigator.mediaDevices.getUserMedia(constraints);

        video.srcObject = stream;
        video.play();

        startCapture(stream);
    }
    catch(error) {
        console.error('Error opening video camera.', error);
        video.pause();
    }
}

playVideoFromDevice()
	.then(resetDevices);

let capture_process;

function startCapture(stream) {
	const settings = stream.getVideoTracks()[0].getSettings();

	console.log(`Video settings: ${settings.width}x${settings.height}@${settings.frameRate.toFixed(1)}fps`);

	capture.width = settings.width;
	capture.height = settings.height;

	processed.width = settings.width;
	processed.height = settings.height / 2;

	captureFrame();
}

let start;

async function captureFrame() {
	try {
		capture_ctx.drawImage(video, 0, 0, capture.width, capture.height);

		start = Date.now();

		const pixels = capture_ctx.getImageData(0, 0, capture.width, capture.height);

		processFrame(pixels);
	}
	catch(err) {
		console.error(err);
	}

	capture_process = window.requestAnimationFrame(captureFrame);
}

function processFrame(pixels) {
	// de-interlace: top + drop

	const pixels_per_rows = pixels.width * 4;
	const max_rows = pixels.height / 2;

	for (let row_idx = 1; row_idx < max_rows; row_idx++) {
		const slice = pixels.data.slice(
			pixels_per_rows * row_idx * 2,
			pixels_per_rows * (row_idx * 2 + 1)
		);

		pixels.data.set(slice, pixels_per_rows * row_idx);
	}

	processed_ctx.putImageData(pixels, 0, 0, 0, 0, pixels_per_rows, max_rows);

	processTasks(pixels);

	console.log(Date.now() - start);

	/*
	worker.postMessage(
		{
			width: pixels_per_rows,
			height: max_rows,
			data: pixels.data,
		},
		[
			pixels.data.buffer
		]
	);
	/**/
}

console.log('loading worker');
const worker = new Worker('./worker.js');

const x=0, y=0, w=100, h=7;

const config = {
	deinterlace: true,
	tasks: [
		{name: 'score', crop: [526, 62, 118, 7], pattern: "DDDDDD", red: false},
		{name: 'level', crop: [566, 166, 38, 7], pattern: "TD", red: false},
		{name: 'lines', crop: [426, 22, 57, 7], pattern: "TDD", red: false},
		{name: 'field', crop: [284, 46, 201, 160]},
		{name: 'stats', crop: [164, 93, 57, 105]},
	]
};

worker.postMessage({
	command: 'set_config',
	args: [ config ]
});

worker.addEventListener('message', function(evt) {
	// first message is ready
}, false);


function processTasks(pixels) {
	config.tasks.forEach(task => {
		const canva = dom[task.name];
		const ctx = dom[`${task.name}_ctx`];
		const [x, y, w, h] = task.crop;

		canva.width = w;
		canva.height = h;

		ctx.putImageData(pixels, -x, -y, x, y, w, h);
	});
}

</script>
</body>
</html>