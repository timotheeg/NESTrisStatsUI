<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="tetris.css" />
<link rel="stylesheet" type="text/css" href="debug.css" />
<style>
html {
	overflow: hidden;
}
#stream_bg {
	background: black;
}

#playing_fields {
	position: absolute;
	left: 640px;
	top: 23px;
}

.box {
	width: 95px;
	height: 56px;
	text-align: center;
}

.box .header {
	font-size: 16px;
	padding-bottom: 0.5em;
}

.box .content,
.box .data {
	font-size: 24px;
	line-height: 30px;
}

.score {
	top: 76px;
	height: 60px;
	left: -107px;
	width: 168px;
}

.score .diff {
	text-align: center;
}

.next_piece {
	width: 104px;
	height: 60px;
	top: 6px;

	--offset: 177px;
	right: var(--offset)
}

.lines {
	left: -107px;
	top: 160px;
}

.level {
	left: -107px;
	top: 241px;
}

.board {
	border-image: url('./big_border.png');
	border-image-slice: 16 16 16 16 fill;
	border-image-width: 16px 16px;
	padding: 17px;
	width: 237px;
	height: 477px;
	top: 76px;

	--offset: 106px;
	right: var(--offset)
}

.tetris_rate {
	left: -107px;
	top: 588px;
}

.efficiency {
	left: -107px;
	top: 507px;
}

.tetris_rate .content {
	padding: 0 5px;
}

.running_trt {
	padding: 9px;
	width: 253px;
	height: 62px;
	top: 588px;

	--offset: 106px;
	right: var(--offset)
}

</style>
</head>
<body>

<textarea id="cur_frame"></textarea>
<textarea id="next_frame"></textarea>


<button id="goto_next_frame">Next Frame</button>
<button id="goto_next_frame_debug">Next Frame Debug</button>
<button id="play">Play</button>
<button id="stop">Stop</button>
<div id="skip"><input class="to"></body><button class="btn">Skip to</button></div>


<div id="stream_bg">
<div id="bg_pieces"></div>

<div id="playing_fields">
<div class="box board"></div>
<div class="box next_piece"></div>


<!-- Player 1 -->

<div class="box score">
	<div class="header">SCORE</div>
	<div class="content">000000</div>
</div>

<div class="box lines">
	<div class="header">LINES</div>
	<div class="content">000</div>
</div>

<div class="box level">
	<div class="header">LEVEL</div>
	<div class="content">000</div>
</div>

<div class="box tetris_rate">
	<div class="header">TRT</div>
	<div class="content">---</div>
</div>


<div class="box efficiency">
	<div class="header">EFF</div>
	<div class="content">---</div>
</div>


<div class="box running_trt"></div>

</div><!-- End Playing Fields -->
</div><!-- End Stream BG -->


<!-- Audio -->

<script src="sample_frames_11.js"></script>
<script src="constants.js"></script>
<script src="utils.js"></script>
<script src="bg.js"></script>
<script src="Player.js"></script>
<script >
const player = new Player(
	{
		score:       document.querySelector(`.score .content`),
		level:       document.querySelector(`.level .content`),
		lines:       document.querySelector(`.lines .content`),
		trt:         document.querySelector(`.tetris_rate .content`),
		eff:         document.querySelector(`.efficiency .content`),
		running_trt: document.querySelector(`.running_trt`),
		preview:     document.querySelector(`.next_piece`),
		field:       document.querySelector(`.board`)
	},
	{
		format_score: 0,
		tetris_sound: 0,
	}
);

const frame_buffer = [];
let combined_board = Array(20).fill().map(_ => Array(10).fill(0));
let cur_board;
let last_frame;
let last_board;
let game_id;
let top_empty;
let remaining_clear_animation_frames;


function reset() {
	combined_board = Array(20).fill().map(_ => Array(10).fill(0));
	frame_buffer.length = 0;
	last_frame = '';
	last_board = null;
	top_empty = true;
	remaining_clear_animation_frames = 0;
}

reset();

function toBoard(str) {
	let field = str.split('').map(d => parseInt(d, 10));
	const rows = Array(20).fill().map((v, i) => field.slice(i * 10, i * 10 + 10));

	rows.num_block = str.replace(/0+/g, '').length;

	return rows;
}

function boardToStr(board) {
	return board.map(r => r.join('')).join('');
}

function isRowEmpty(row) {
	return 0 === row.reduce((sum, v) => sum + v, 0);
}

function isRowPotentiallyFirstFrameOfClearAnimation(row) {
	return (
		   row[4] === 1
		&& row[5] === 1
		&& 2 === row.reduce((sum, v) => sum + v, 0)
	);
}

function isRowPotentiallySecondFrameOfDoubleClearAnimation(row) {
	return (
		   row[3] === 1
		&& row[4] === 1
		&& row[5] === 1
		&& row[6] === 1
		&& 4 === row.reduce((sum, v) => sum + v, 0)
	);
}

// detect first animation frame for singles, triples, tetris
function isFirstFrameOfClearAnimation(board) {
	if (board.num_block != 2
		&& board.num_block != 6
		&& board.num_block != 8
	) {
		return false;
	}

	let ridx, top_idx, lines;

	for (ridx=1; ridx<20; ridx++) {
		const row = board[ridx];

		if (isRowEmpty(row)) {
			continue;
		}
		else if (isRowPotentiallyFirstFrameOfClearAnimation(row)) {
			top_idx = ridx;
			lines = 1;

			if (ridx < 18
				&& isRowPotentiallyFirstFrameOfClearAnimation(board[++ridx])
				&& isRowPotentiallyFirstFrameOfClearAnimation(board[++ridx])
			) {
				lines = 3;

				if (ridx < 19 && isRowPotentiallyFirstFrameOfClearAnimation(board[++ridx])) {
					lines = 4;
				}
			}

			break;
		}
		else {
			return false;
		}
	}


	// verify all remaining rows are empty
	for (; ridx<20; ridx++) {
		const row = board[ridx];

		if (!isRowEmpty(row)) return false;
	}

	board.clear_data = { top_idx, lines };

	return true;
}

function isSecondFrameOfDoubleClearAnimation(board) {
	if (board.num_block != 8) {
		return false;
	}

	let ridx, top_idx, lines;

	for (ridx=1; ridx<19; ridx++) {
		const row = board[ridx];

		if (isRowEmpty(row)) {
			continue;
		}
		else if (isRowPotentiallySecondFrameOfDoubleClearAnimation(row)) {
			top_idx = ridx;

			if (isRowPotentiallySecondFrameOfDoubleClearAnimation(board[++ridx])) {
				lines = 2;

				return { top_idx, lines };
			}
			else {
				break;
			}
		}
		else {
			break;
		}
	}

	return false;
}

const CLEAR_ANIMATION_FRAMES = 7;

function handleFrame(frame) {
	if (frame.gameid !== game_id) {
		game_id = frame.gameid;
		reset();
	}

	const last_board = peek(frame_buffer) && peek(frame_buffer)._board;

	if (last_frame === frame.field) {
		frame_buffer.push({
			...frame,
			field: peek(frame_buffer).field,
			_board: peek(frame_buffer)._board,
		});
	}
	else {
		last_frame = frame.field;

		let new_board = toBoard(frame.field);

		frame._board = new_board;

		if (remaining_clear_animation_frames-- > 0) {
			new_board._clear = true;

			new_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 1) {
					combined_board[ridx][cidx] = 0;
				}
			}));

			if (remaining_clear_animation_frames === 0) {
				// last frame of clear animation, we need to remove all empty lines
				// MUST RUN BEFORE NEXT PIECE APPEARS!!!!
				const empty_rows = combined_board.filter(row => row.every(cell => cell === 0));
				const filled_rows = combined_board.filter(row => row.some(cell => cell > 0));

				combined_board = [
					...empty_rows,
					...filled_rows
				];
			}

			cur_board = combined_board;
		}
		else if (new_board.num_block === 0
			&& last_board
			&& !last_board._clear) {
			// preparing clear animation
			remaining_clear_animation_frames = CLEAR_ANIMATION_FRAMES;

			// record prev piece settling
			last_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 0) return;

				combined_board[ridx][cidx] = cell + 3;
			}));

			cur_board = combined_board;
		}
		else if (isFirstFrameOfClearAnimation(new_board)) {
			// preparing clear animation
			remaining_clear_animation_frames = CLEAR_ANIMATION_FRAMES - 1;

			new_board._clear = true;

			// record prev piece settling
			last_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 0) return;

				combined_board[ridx][cidx] = cell + 3;
			}));

			// remove the block from the clear animation
			new_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 1) {
					combined_board[ridx][cidx] = 0;
				}
			}));

			cur_board = combined_board;
		}
		else if (isSecondFrameOfDoubleClearAnimation(new_board)) {
			// preparing clear animation
			remaining_clear_animation_frames = CLEAR_ANIMATION_FRAMES - 2;

			new_board._clear = true;
			last_board._clear = true;

			// 1. record prev piece settling
			peek(frame_buffer, 1).forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 0) return;

				combined_board[ridx][cidx] = cell + 3;
			}));

			// remove the block from the clear animation
			new_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
				if (cell === 1) {
					combined_board[ridx][cidx] = 0;
				}
			}));

			cur_board = combined_board;
		}
		else if (new_board.num_block <= 8) { // 8 to account for stupid double count due to interlacing...
			// piece is falling, we need to display its temporary location
			const new_top_empty = new_board.slice(0, 2).filter(row => row.every(cell => cell === 0)).length === 2;

			if (!new_top_empty && last_board) {
				// check if last_board's piece was below 16
				last_top_idx = last_board.map((row, idx) => row.some(cell => cell > 0) ? idx : -1).find(v => v > -1);

				if (last_top_idx > 3) {
					// record prev piece settling
					last_board.forEach((row, ridx) => row.forEach((cell, cidx) => {
						if (cell === 0) return;

						combined_board[ridx][cidx] = cell + 3;
					}));
				}
			}

			cur_board = combined_board.map((row, ridx) => [...row].map((cell, cidx) => {
				return new_board[ridx][cidx] || cell;
			}));
		}

		frame_buffer.push({
			...frame,
			field: boardToStr(cur_board)
		});
	}

	if (frame_buffer.length >= 2) {
		player.setFrame( frame_buffer.shift() );
	}
}


var captured_frames = []

const API = {
	frame(data) {
		// captured_frames.push(data);
		try {
			handleFrame(data);
		}
		catch(e) {
			console.error(e);
		}
	}
}

const socket = new WebSocket('ws://127.0.0.1:3339');

socket.addEventListener('message', (frame => {
	try{
		const [method, ...args] = JSON.parse(frame.data); // expect array of format [api_method_name, arg1, arg2, ...]

		API[method].apply(API, args);
	}
	catch(e) {
		console.error(e);
	}
}));


function onFrame(frame, debug) {
	API.frame(frame, debug);
}
</script>

<script src="sample_frames_15.js"></script>
<script src="debug.js"></script>


</body>
<html>